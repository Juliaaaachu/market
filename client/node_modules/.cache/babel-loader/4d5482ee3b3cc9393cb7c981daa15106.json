{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst InternalCache = require('./internal');\n\nconst MongooseError = require('./error/index');\n\nconst MixedSchema = require('./schema/mixed');\n\nconst ObjectExpectedError = require('./error/objectExpected');\n\nconst ObjectParameterError = require('./error/objectParameter');\n\nconst ParallelValidateError = require('./error/parallelValidate');\n\nconst Schema = require('./schema');\n\nconst StrictModeError = require('./error/strict');\n\nconst ValidationError = require('./error/validation');\n\nconst ValidatorError = require('./error/validator');\n\nconst VirtualType = require('./virtualtype');\n\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\n\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\n\nconst compile = require('./helpers/document/compile').compile;\n\nconst defineKey = require('./helpers/document/compile').defineKey;\n\nconst flatten = require('./helpers/common').flatten;\n\nconst get = require('./helpers/get');\n\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\n\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\n\nconst idGetter = require('./plugins/idGetter');\n\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\n\nconst isExclusive = require('./helpers/projection/isExclusive');\n\nconst inspect = require('util').inspect;\n\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\n\nconst mpath = require('mpath');\n\nconst queryhelpers = require('./queryhelpers');\n\nconst utils = require('./utils');\n\nconst isPromise = require('./helpers/isPromise');\n\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\nconst arrayAtomicsBackupSymbol = Symbol('mongoose.Array#atomicsBackup');\n\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\n\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\n\nconst documentIsSelected = require('./helpers/symbols').documentIsSelected;\n\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\n\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\n\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\n\nconst getSymbol = require('./helpers/symbols').getSymbol;\n\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\n\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\nconst specialProperties = utils.specialProperties;\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n\n  options = Object.assign({}, options);\n  const defaults = get(options, 'defaults', true);\n  options.defaults = defaults; // Support `browserDocument.js` syntax\n\n  if (this.schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;\n\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache();\n  this.$__.emitter = new EventEmitter();\n  this.isNew = 'isNew' in options ? options.isNew : true;\n  this.errors = undefined;\n  this.$__.$options = options || {};\n  this.$locals = {};\n  this.$op = null;\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  const schema = this.schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n  let exclude = null; // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (utils.isPOJO(fields)) {\n    exclude = isExclusive(fields);\n  }\n\n  const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : {};\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false); // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n\n    if (defaults) {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {\n        isNew: this.isNew\n      });\n    }\n  }\n\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true);\n    } else {\n      this.$set(obj, undefined, true);\n    }\n\n    if (obj instanceof Document) {\n      this.isNew = obj.isNew;\n    }\n  } // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n\n\n  if (options.willInit && defaults) {\n    EventEmitter.prototype.once.call(this, 'init', () => {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n        isNew: this.isNew\n      });\n    });\n  } else if (defaults) {\n    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n      isNew: this.isNew\n    });\n  }\n\n  this.$__._id = this._id;\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n\n    const keys = Object.keys(this._doc);\n    keys.forEach(function (key) {\n      if (!(key in schema.tree)) {\n        defineKey(key, null, _this);\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\n\n\nutils.each(['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners', 'removeAllListeners', 'addListener'], function (emitterFn) {\n  Document.prototype[emitterFn] = function () {\n    return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n  };\n});\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n/**\n * The documents schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.schema;\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * ####Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.isNew;\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.errors;\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * ####Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$op;\n/*!\n * ignore\n */\n\nfunction $__hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n\n  for (const key of keys) {\n    const parts = key.split('.');\n    const c = [];\n\n    for (const part of parts) {\n      c.push(part);\n      hasIncludedChildren[c.join('.')] = 1;\n    }\n  }\n\n  return hasIncludedChildren;\n}\n/*!\n * ignore\n */\n\n\nfunction $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && skipId) {\n      continue;\n    }\n\n    const type = doc.schema.paths[p];\n    const path = p.indexOf('.') === -1 ? [p] : p.split('.');\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (typeof type.defaultValue === 'function') {\n          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n            break;\n          }\n\n          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n            break;\n          }\n        } else if (!isBeforeSetters) {\n          // Non-function defaults should always run **before** setters\n          continue;\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            doc.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n}\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__buildDoc = function (obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n  const paths = Object.keys(this.schema.paths). // Don't build up any paths that are underneath a map, we don't know\n  // what the keys will be\n  filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = p.split('.');\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n      curPath += (!curPath.length ? '' : '.') + piece; // support excluding intermediary levels\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n/*!\n * Converts to POJO when you use the document for querying\n */\n\n\nDocument.prototype.toBSON = function () {\n  return this.toObject(internalToObjectOptions);\n};\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.init = function (doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__init = function (doc, opts) {\n  this.isNew = false;\n  this.$init = true;\n  opts = opts || {}; // handle docs with populated paths\n  // If doc._id is not null or undefined\n\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n\n        child.$__.parent = this;\n      }\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n  markArraySubdocsPopulated(this, opts.populated);\n  this.emit('init', this);\n  this.constructor.emit('init', this);\n  this.$__._id = this._id;\n  return this;\n};\n/*!\n * If populating a path within a document array, make sure each\n * subdoc within the array knows its subpaths are populated.\n *\n * ####Example:\n *     const doc = await Article.findOne().populate('comments.author');\n *     doc.comments[0].populated('author'); // Should be set\n */\n\n\nfunction markArraySubdocsPopulated(doc, populated) {\n  if (doc._id == null || populated == null || populated.length === 0) {\n    return;\n  }\n\n  const id = String(doc._id);\n\n  for (const item of populated) {\n    if (item.isVirtual) {\n      continue;\n    }\n\n    const path = item.path;\n    const pieces = path.split('.');\n\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const rest = pieces.slice(i + 1).join('.');\n      const val = doc.get(subpath);\n\n      if (val == null) {\n        continue;\n      }\n\n      if (val.isMongooseDocumentArray) {\n        for (let j = 0; j < val.length; ++j) {\n          val[j].populated(rest, item._docs[id] == null ? [] : item._docs[id][j], item);\n        }\n\n        break;\n      }\n    }\n  }\n}\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schema;\n  let path;\n  let i;\n  let index = 0;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.schema.path(path); // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n\n    if (self.schema.$isRootDiscriminator && !self.isSelected(path)) {\n      return;\n    }\n\n    if (!schema && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schema) {\n      doc[i] = obj[i];\n    } else {\n      if (obj[i] === null) {\n        doc[i] = schema._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const intCache = obj[i].$__ || {};\n        const wasPopulated = intCache.wasPopulated || null;\n\n        if (schema && !wasPopulated) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      } // mark as hydrated\n\n\n      if (!self.isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.update = function update() {\n  const args = utils.args(arguments);\n  args.unshift({\n    _id: this._id\n  });\n  const query = this.constructor.update.apply(this.constructor, args);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  return query;\n};\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model.updateOne)\n *\n * @see Model.updateOne #model_Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({\n    _id: this._id\n  }, doc, options);\n\n  query._pre(cb => {\n    this.constructor._middleware.execPre('updateOne', this, [this], cb);\n  });\n\n  query._post(cb => {\n    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * ####Valid options:\n *\n *  - same as in [Model.replaceOne](#model_Model.replaceOne)\n *\n * @see Model.replaceOne #model_Model.replaceOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = utils.args(arguments);\n  args.unshift({\n    _id: this._id\n  });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * ####Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    return this.$__.session;\n  }\n\n  this.$__.session = session;\n\n  if (!this.ownerDocument) {\n    const subdocs = this.$__getAllSubdocs();\n\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @name overwrite\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    } // Explicitly skip version key\n\n\n    if (this.schema.options.versionKey && key === this.schema.options.versionKey) {\n      continue;\n    }\n\n    if (this.schema.options.discriminatorKey && key === this.schema.options.discriminatorKey) {\n      continue;\n    }\n\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @method $set\n * @name $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  options = options || {};\n  const merge = options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n  const strict = 'strict' in options ? options.strict : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n\n    if (path == null) {\n      const _ = path;\n      path = val;\n      val = _;\n    } else {\n      prefix = val ? val + '.' : '';\n      keys = Object.keys(path);\n      const len = keys.length; // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n      // nested key to ensure key order.\n\n      const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);\n\n      if (len === 0 && _skipMinimizeTopLevel) {\n        delete options._skipMinimizeTopLevel;\n\n        if (val) {\n          this.$set(val, {});\n        }\n\n        return this;\n      }\n\n      while (i < len) {\n        _handleIndex.call(this, i++);\n      }\n\n      return this;\n    }\n  } else {\n    this.$__.$setCalled.add(path);\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    const pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName); // On initial set, delete any nested keys if we're going to overwrite\n    // them to ensure we keep the user's key order.\n\n    if (type === true && !prefix && path[key] != null && pathtype === 'nested' && this._doc[key] != null && Object.keys(this._doc[key]).length === 0) {\n      delete this._doc[key]; // Make sure we set `{}` back even if we minimize re: gh-8565\n\n      options = Object.assign({}, options, {\n        _skipMinimizeTopLevel: true\n      });\n    }\n\n    if (typeof path[key] === 'object' && !utils.isNativeObject(path[key]) && !utils.isMongooseType(path[key]) && path[key] != null && pathtype !== 'virtual' && pathtype !== 'real' && pathtype !== 'adhocOrUndefined' && !(this.$__path(pathName) instanceof MixedSchema) && !(this.schema.paths[pathName] && this.schema.paths[pathName].options && this.schema.paths[pathName].options.ref)) {\n      this.$__.$setCalled.add(prefix + key);\n      this.$set(path[key], prefix + key, constructing, options);\n    } else if (strict) {\n      // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n      if (constructing && path[key] === void 0 && this.get(pathName) !== void 0) {\n        return;\n      }\n\n      if (pathtype === 'adhocOrUndefined') {\n        pathtype = getEmbeddedDiscriminatorPath(this, pathName, {\n          typeOnly: true\n        });\n      }\n\n      if (pathtype === 'real' || pathtype === 'virtual') {\n        // Check for setting single embedded schema to document (gh-3535)\n        let p = path[key];\n\n        if (this.schema.paths[pathName] && this.schema.paths[pathName].$isSingleNested && path[key] instanceof Document) {\n          p = p.toObject({\n            virtuals: false,\n            transform: false\n          });\n        }\n\n        this.$set(prefix + key, p, constructing, options);\n      } else if (pathtype === 'nested' && path[key] instanceof Document) {\n        this.$set(prefix + key, path[key].toObject({\n          transform: false\n        }), constructing, options);\n      } else if (strict === 'throw') {\n        if (pathtype === 'nested') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.$set(prefix + key, path[key], constructing, options);\n    }\n  }\n\n  let pathType = this.schema.pathType(path);\n\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, {\n      typeOnly: true\n    });\n  } // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n\n\n  val = handleSpreadDoc(val);\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = Object.keys(val);\n      this.$__setValue(path, {});\n\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing);\n      }\n\n      this.markModified(path);\n      cleanModifiedSubpaths(this, path, {\n        skipDocArrays: true\n      });\n      return this;\n    }\n\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.'); // Might need to change path for top-level alias\n\n  if (typeof this.schema.aliases[parts[0]] == 'string') {\n    parts[0] = this.schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.'); // If path is underneath a virtual, bypass everything and just set it.\n\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.schema.path(subpath);\n\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  } // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n\n\n  let cur = this._doc;\n  let curPath = '';\n\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length > 0 ? '.' : '') + parts[i];\n\n    if (!cur) {\n      this.$set(curPath, {}); // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n\n      if (!this.isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark; // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      if (this.get(subpath, null, {\n        getters: false\n      }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  } // if this doc is being constructed we should not trigger getters\n\n\n  const priorVal = (() => {\n    if (this.$__.$options.priorDoc != null) {\n      return this.$__.$options.priorDoc.$__getValue(path);\n    }\n\n    if (constructing) {\n      return void 0;\n    }\n\n    return this.$__getValue(path);\n  })();\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  } // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n\n\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (schema.$isSingleNested && val != null && merge) {\n    if (val instanceof Document) {\n      val = val.toObject({\n        virtuals: false,\n        transform: false\n      });\n    }\n\n    const keys = Object.keys(val);\n\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n\n      if (!(val instanceof Document)) {\n        return false;\n      }\n\n      const model = val.constructor; // Check ref\n\n      const ref = schema.options.ref;\n\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      } // Check refPath\n\n\n      const refPath = schema.options.refPath;\n\n      if (refPath == null) {\n        return false;\n      }\n\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n\n    if (refMatches && val instanceof Document) {\n      this.populated(path, val._id, {\n        [populateModelSymbol]: val.constructor\n      });\n      didPopulate = true;\n    }\n\n    let popOpts;\n\n    if (schema.options && Array.isArray(schema.options[this.schema.options.typeKey]) && schema.options[this.schema.options.typeKey].length && schema.options[this.schema.options.typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[this.schema.options.typeKey][0].ref)) {\n      if (this.ownerDocument) {\n        popOpts = {\n          [populateModelSymbol]: val[0].constructor\n        };\n        this.ownerDocument().populated(this.$__fullPath(path), val.map(function (v) {\n          return v._id;\n        }), popOpts);\n      } else {\n        popOpts = {\n          [populateModelSymbol]: val[0].constructor\n        };\n        this.populated(path, val.map(function (v) {\n          return v._id;\n        }), popOpts);\n      }\n\n      didPopulate = true;\n    }\n\n    if (this.schema.singleNestedPaths[path] == null) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      val = schema.applySetters(val, this, false, priorVal);\n    }\n\n    if (schema.$isMongooseDocumentArray && Array.isArray(val) && val.length > 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n\n      for (const populatedPath of populatedPaths) {\n        this.populated(path + '.' + populatedPath, val.map(v => v.populated(populatedPath)), val[0].$__.populated[populatedPath].options);\n      }\n\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val[i] = val[i]._id;\n          }\n        }\n      }\n\n      delete this.$__.populated[path];\n    }\n\n    if (schema.$isSingleNested && val != null) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n\n      if (e.$originalErrorPath) {\n        this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));\n    }\n\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n\n    const modelName = el.constructor.modelName;\n\n    if (modelName == null) {\n      return false;\n    }\n\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.set = Document.prototype.$set;\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  } // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n\n\n  if (this.schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n\n  if (val === void 0 && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  } // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n\n\n  if (this.populated(path) && val instanceof Document && deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing && val !== null && val !== undefined && path in this.$__.activePaths.states.default && deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n\n  return false;\n};\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__set = function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/embedded');\n  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts, schema, val, priorVal);\n\n  const _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark); // handle directly setting arrays (gh-1126)\n\n    MongooseArray || (MongooseArray = require('./types/array'));\n\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val); // Update embedded document parent references (gh-5189)\n\n\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function (item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      } // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n\n\n      this.$__.activePaths.forEach(function (modifiedPath) {\n        if (modifiedPath.startsWith(path + '.')) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += cur ? '.' + parts[i] : parts[i];\n\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\n\nDocument.prototype.$__getValue = function (path) {\n  return utils.getValue(path, this._doc);\n};\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\n\nDocument.prototype.$__setValue = function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @api public\n */\n\n\nDocument.prototype.get = function (path, type, options) {\n  let adhoc;\n  options = options || {};\n\n  if (type) {\n    adhoc = this.schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  let schema = this.$__path(path);\n\n  if (schema == null) {\n    schema = this.schema.virtualpath(path);\n  }\n\n  if (schema instanceof MixedSchema) {\n    const virtual = this.schema.virtualpath(path);\n\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n\n  const pieces = path.split('.');\n  let obj = this._doc;\n\n  if (schema instanceof VirtualType) {\n    if (schema.getters.length === 0) {\n      return void 0;\n    }\n\n    return schema.applyGetters(null, this);\n  } // Might need to change path for top-level alias\n\n\n  if (typeof this.schema.aliases[pieces[0]] == 'string') {\n    pieces[0] = this.schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], {\n        getters: false\n      });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, {\n      path: path\n    });\n  }\n\n  return obj;\n};\n/*!\n * ignore\n */\n\n\nDocument.prototype[getSymbol] = Document.prototype.get;\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function (path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n\n  return this.schema.path(path);\n};\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\n\nDocument.prototype.markModified = function (path, scope) {\n  this.$__.activePaths.modify(path);\n\n  if (scope != null && !this.ownerDocument) {\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\n\nDocument.prototype.unmarkModified = function (path) {\n  this.$__.activePaths.init(path);\n  delete this.$__.pathsToScopes[path];\n};\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\n\nDocument.prototype.$ignore = function (path) {\n  this.$__.activePaths.ignore(path);\n};\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * ####Example\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {Array}\n * @api public\n */\n\n\nDocument.prototype.directModifiedPaths = function () {\n  return Object.keys(this.$__.activePaths.states.modify);\n};\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * ####Example:\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\n\nDocument.prototype.$isEmpty = function (path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length > 0) {\n    const v = this.get(path);\n\n    if (v == null) {\n      return true;\n    }\n\n    if (typeof v !== 'object') {\n      return false;\n    }\n\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {Array}\n * @api public\n */\n\n\nDocument.prototype.modifiedPaths = function (options) {\n  options = options || {};\n  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n\n  const _this = this;\n\n  return directModifiedPaths.reduce(function (list, path) {\n    const parts = path.split('.');\n    list = list.concat(parts.reduce(function (chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function (chain) {\n      return list.indexOf(chain) === -1;\n    }));\n\n    if (!options.includeChildren) {\n      return list;\n    }\n\n    let cur = _this.get(path);\n\n    if (cur != null && typeof cur === 'object') {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n\n      if (Array.isArray(cur)) {\n        const len = cur.length;\n\n        for (let i = 0; i < len; ++i) {\n          if (list.indexOf(path + '.' + i) === -1) {\n            list.push(path + '.' + i);\n\n            if (cur[i] != null && cur[i].$__) {\n              const modified = cur[i].modifiedPaths();\n\n              for (const childPath of modified) {\n                list.push(path + '.' + i + '.' + childPath);\n              }\n            }\n          }\n        }\n      } else {\n        Object.keys(cur).filter(function (key) {\n          return list.indexOf(path + '.' + key) === -1;\n        }).forEach(function (key) {\n          list.push(path + '.' + key);\n        });\n      }\n    }\n\n    return list;\n  }, []);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n/**\n * Returns true if this document was modified, else false.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function (paths, modifiedPaths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    const isModifiedChild = paths.some(function (path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function (path) {\n      return directModifiedPaths.some(function (mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function (path) {\n  return path in this.$__.activePaths.states.default;\n};\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * ####Example:\n *     product.remove(function (err, product) {\n *       product.$isDeleted(); // true\n *       product.remove(); // no-op, doesn't send anything to the db\n *\n *       product.$isDeleted(false);\n *       product.$isDeleted(); // false\n *       product.remove(); // will execute a remove against the db\n *     })\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.$isDeleted = function (val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isDirectModified = function (path) {\n  return path in this.$__.activePaths.states.modify;\n};\n/**\n * Checks if `path` was initialized.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isInit = function (path) {\n  return path in this.$__.activePaths.states.init;\n};\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     Thing.findOne().select('name').exec(function (err, doc) {\n *        doc.isSelected('name') // true\n *        doc.isSelected('age')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    const paths = Object.keys(this.$__.selected);\n    let i = paths.length;\n    let inclusive = null;\n    let cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (!isDefiningProjection(this.$__.selected[cur])) {\n        continue;\n      }\n\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    const pathDot = path + '.';\n\n    while (i--) {\n      cur = paths[i];\n\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (cur.startsWith(pathDot)) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.startsWith(cur + '.')) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n\nDocument.prototype[documentIsSelected] = Document.prototype.isSelected;\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * ####Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    const paths = Object.keys(this.$__.selected);\n    let i = paths.length;\n    let inclusive = null;\n    let cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (!isDefiningProjection(this.$__.selected[cur])) {\n        continue;\n      }\n\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\n\nDocument.prototype.validate = function (pathsToValidate, options, callback) {\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.ownerDocument != null) {// Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack\n    });\n  }\n\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = pathsToValidate;\n    pathsToValidate = null;\n  }\n\n  return promiseOrCallback(callback, cb => {\n    if (parallelValidate != null) {\n      return cb(parallelValidate);\n    }\n\n    this.$__validate(pathsToValidate, options, error => {\n      this.$op = null;\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n/*!\n * ignore\n */\n\n\nfunction _evaluateRequiredFunctions(doc) {\n  Object.keys(doc.$__.activePaths.states.require).forEach(path => {\n    const p = doc.schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n    }\n  });\n}\n/*!\n * ignore\n */\n\n\nfunction _getPathsToValidate(doc) {\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc); // only validate required fields when necessary\n\n\n  let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function (path) {\n    if (!doc.isSelected(path) && !doc.isModified(path)) {\n      return false;\n    }\n\n    if (path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n\n    return true;\n  }));\n  Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);\n\n  function addToPaths(p) {\n    paths.add(p);\n  }\n\n  const subdocs = doc.$__getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc\n      for (const p of paths) {\n        if (p === null || p.startsWith(subdoc.$basePath + '.')) {\n          paths.delete(p);\n        }\n      }\n\n      if (doc.isModified(subdoc.$basePath, modifiedPaths) && !doc.isDirectModified(subdoc.$basePath) && !doc.$isDefault(subdoc.$basePath)) {\n        paths.add(subdoc.$basePath);\n        skipSchemaValidators[subdoc.$basePath] = true;\n      }\n    }\n  } // from here on we're not removing items from paths\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n\n\n  for (const path of paths) {\n    const _pathType = doc.schema.path(path);\n\n    if (!_pathType || !_pathType.$isMongooseArray || // To avoid potential performance issues, skip doc arrays whose children\n    // are not required. `getPositionalPathType()` may be slow, so avoid\n    // it unless we have a case of #6364\n    _pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required')) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = {\n    skipArrays: true\n  };\n\n  for (const pathToCheck of paths) {\n    if (doc.schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({\n          transform: false\n        });\n      }\n\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n\n    const _pathType = doc.schema.path(path);\n\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n\n    if (val == null) {\n      continue;\n    }\n\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, skipSchemaValidators];\n}\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__validate = function (pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  let shouldValidateModifiedOnly;\n\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = undefined;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n\n      for (const errPath of errors) {\n        if (!this.isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.emit('validate', _this);\n    this.constructor.emit('validate', _this);\n    this.$__.validating = null;\n\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  }; // only validate required fields when necessary\n\n\n  const pathDetails = _getPathsToValidate(this);\n\n  let paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  }\n\n  if (paths.length === 0) {\n    return process.nextTick(function () {\n      const error = _complete();\n\n      if (error) {\n        return _this.schema.s.hooks.execPost('validate:error', _this, [_this], {\n          error: error\n        }, function (error) {\n          callback(error);\n        });\n      }\n\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  const complete = function () {\n    const error = _complete();\n\n    if (error) {\n      return _this.schema.s.hooks.execPost('validate:error', _this, [_this], {\n        error: error\n      }, function (error) {\n        callback(error);\n      });\n    }\n\n    callback(null, _this);\n  };\n\n  const validatePath = function (path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n    process.nextTick(function () {\n      const schemaType = _this.schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      } // If user marked as invalid or there was a cast error, don't validate\n\n\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      let val = _this.$__getValue(path); // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n\n\n      let pop;\n\n      if (val == null && (pop = _this.populated(path))) {\n        val = pop;\n      }\n\n      const scope = path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;\n      const doValidateOptions = {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path\n      };\n      schemaType.doValidate(val, function (err) {\n        if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n          if (schemaType.$isSingleNested && err instanceof ValidationError && schemaType.schema.options.storeSubdocValidationError === false) {\n            return --total || complete();\n          }\n\n          _this.invalidate(path, err, undefined, true);\n        }\n\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  };\n\n  const numPaths = paths.length;\n\n  for (let i = 0; i < numPaths; ++i) {\n    validatePath(paths[i]);\n  }\n};\n/*!\n * ignore\n */\n\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n\n  const parentPaths = new Map([]);\n\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n\n    const pieces = path.split('.');\n    let cur = pieces[0];\n\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = [];\n\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.push(path);\n    } else if (parentPaths.has(path)) {\n      ret.push(parentPaths.get(path));\n    }\n  }\n\n  return ret;\n}\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\n\nDocument.prototype.validateSync = function (pathsToValidate, options) {\n  const _this = this;\n\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  let shouldValidateModifiedOnly;\n\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;\n  }\n\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  } // only validate required fields when necessary\n\n\n  const pathDetails = _getPathsToValidate(this);\n\n  let paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  }\n\n  const validating = {};\n  paths.forEach(function (path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    const p = _this.schema.path(path);\n\n    if (!p) {\n      return;\n    }\n\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    const val = _this.$__getValue(path);\n\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path\n    });\n\n    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n      if (p.$isSingleNested && err instanceof ValidationError && p.schema.options.storeSubdocValidationError === false) {\n        return;\n      }\n\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n\n  _this.emit('validate', _this);\n\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\n\nDocument.prototype.invalidate = function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\n\nDocument.prototype.$markValid = function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n/*!\n * ignore\n */\n\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key); // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](/docs/api.html#document_Document-isNew) is `true`,\n * or sends an [updateOne](/docs/api.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * ####Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](api.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String} path the field to check\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\n\nDocument.prototype.$isValid = function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n};\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  this.$__.activePaths.map('init', 'modify', function (i) {\n    return _this.$__getValue(i);\n  }).filter(function (val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).forEach(function (array) {\n    let i = array.length;\n\n    while (i--) {\n      const doc = array[i];\n\n      if (!doc) {\n        continue;\n      }\n\n      doc.$__reset();\n    }\n\n    _this.$__.activePaths.init(array.$path());\n\n    array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n    array[arrayAtomicsSymbol] = {};\n  });\n  this.$__.activePaths.map('init', 'modify', function (i) {\n    return _this.$__getValue(i);\n  }).filter(function (val) {\n    return val && val.$isSingleNested;\n  }).forEach(function (doc) {\n    doc.$__reset();\n\n    _this.$__.activePaths.init(doc.$basePath);\n  }); // clear atomics\n\n  this.$__dirty().forEach(function (dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.states.modify),\n    default: Object.assign({}, this.$__.activePaths.states.default)\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.errors; // Clear 'dirty' cache\n\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function (path) {\n    _this.$__.activePaths.require(path);\n  });\n  return this;\n};\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n  this.$__.validationError = this.$__.backup.validationError;\n  this.errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$__getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__dirty = function () {\n  const _this = this;\n\n  let all = this.$__.activePaths.map('modify', function (path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }); // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n\n  all = all.concat(this.$__.activePaths.map('default', function (path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  })); // Sort dirty paths in a flat hierarchy.\n\n  all.sort(function (a, b) {\n    return a.path < b.path ? -1 : a.path > b.path ? 1 : 0;\n  }); // Ignore \"foo.a\" if \"foo\" is dirty already.\n\n  const minimal = [];\n  let lastPath;\n  let top;\n  all.forEach(function (item) {\n    if (!item) {\n      return;\n    }\n\n    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + '.';\n      minimal.push(item);\n      top = item;\n    } else if (top != null && top.value != null && top.value[arrayAtomicsSymbol] != null && top.value.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being modified.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top.value[arrayAtomicsSymbol] = {};\n      top.value[arrayAtomicsSymbol].$set = top.value;\n    }\n  });\n  top = lastPath = null;\n  return minimal;\n};\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__setSchema = function (schema) {\n  schema.plugin(idGetter, {\n    deduplicate: true\n  });\n  compile(schema.tree, this, undefined, schema.options); // Apply default getters if virtual doesn't have any (gh-6262)\n\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n\n  this.schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__getArrayPathsToValidate = function () {\n  DocumentArray || (DocumentArray = require('./types/documentarray')); // validate all document arrays.\n\n  return this.$__.activePaths.map('init', 'modify', function (i) {\n    return this.$__getValue(i);\n  }.bind(this)).filter(function (val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function (seed, array) {\n    return seed.concat(array);\n  }, []).filter(function (doc) {\n    return doc;\n  });\n};\n/**\n * Get all subdocs (by bfs)\n *\n * @api private\n * @method $__getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__getAllSubdocs = function () {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  Embedded = Embedded || require('./types/embedded');\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else {\n        val = doc[path];\n      }\n    }\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function (seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function (seed, path) {\n        return docReducer(val._doc, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n\n        seed = Object.keys(doc._doc).reduce(function (seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      seed = Object.keys(val).reduce(function (seed, path) {\n        return docReducer(val, seed, path);\n      }, seed);\n    }\n\n    return seed;\n  }\n\n  const _this = this;\n\n  const subDocs = Object.keys(this._doc).reduce(function (seed, path) {\n    return docReducer(_this, seed, path);\n  }, []);\n  return subDocs;\n};\n/*!\n * Runs queued functions\n */\n\n\nfunction applyQueue(doc) {\n  const q = doc.schema && doc.schema.callQueue;\n\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners('error').length) {\n    this.emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$toObject = function (options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = get(this, 'constructor.base.options.' + path, {});\n  const schemaOptions = get(this, 'schema.options', {}); // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {})); // If options do not exist or is not an object, set it to empty object\n\n  options = utils.isPOJO(options) ? clone(options) : {};\n  options._calledWithOptions = options._calledWithOptions || clone(options);\n\n  if (!('flattenMaps' in options)) {\n    options.flattenMaps = defaultOptions.flattenMaps;\n  }\n\n  let _minimize;\n\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  } // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n\n\n  const cloneOptions = Object.assign(utils.clone(options), {\n    _isNested: true,\n    json: json,\n    minimize: _minimize\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate || get(options, '_parentOptions.depopulate', false); // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, cloneOptions);\n  } // merge default options with input options.\n\n\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = true;\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = false; // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n\n  const originalTransform = options.transform;\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  let transform = options.transform; // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || schemaOptions.toObject && transform) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = typeof options.transform === 'function' ? options.transform : opts.transform;\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n/**\n * Converts this document into a plain javascript object, ready for storage in MongoDB.\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters), defaults to false\n * - `aliases` apply all aliases if `virtuals=true`, defaults to true\n * - `virtuals` apply virtual getters (can override `getters` option), defaults to false\n * - `minimize` remove empty objects, defaults to true\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs, defaults to false\n * - `versionKey` whether to include the version key, defaults to true\n * - `flattenMaps` convert Maps to POJOs. Useful if you want to JSON.stringify() the result of toObject(), defaults to false\n * - `useProjection` set to `true` to omit fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this is behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toObject = function (options) {\n  return this.$toObject(options);\n};\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isObject(val) && !Buffer.isBuffer(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys ? obj : undefined;\n}\n/*!\n * Applies virtuals properties to `json`.\n */\n\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = get(toObjectOptions, 'aliases', true);\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i]; // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    } // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n\n\n    assignPath = path;\n\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n\n      assignPath = path.substr(options.path.length + 1);\n    }\n\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n\n    if (v === void 0) {\n      continue;\n    }\n\n    const plen = parts.length;\n    cur = json;\n\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\n\nfunction applyGetters(self, json, options) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n\n      if (ii === last) {\n        const val = self.get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n\n      cur = v;\n    }\n  }\n\n  return json;\n}\n/*!\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.get(path);\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      json[path] = transformedValue;\n    } else if (schematype.$embeddedSchemaType != null && typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const vals = [].concat(self.get(path));\n      const transform = schematype.$embeddedSchemaType.options.transform;\n\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n/*!\n * ignore\n */\n\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toJSON = function (options) {\n  return this.$toObject(options, true);\n};\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.parent = function () {\n  return this.$__.parent;\n};\n/**\n * Helper for console.log\n *\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.inspect = function (options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toString = function () {\n  const ret = this.inspect();\n\n  if (typeof ret === 'string') {\n    return ret;\n  }\n\n  return inspect(ret);\n};\n/**\n * Returns true if the Document stores the same data as doc.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.equals = function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n\n  return tid && tid.equals ? tid.equals(docid) : tid === docid;\n};\n/**\n * Populates document references, executing the `callback` when complete.\n * If you want to use promises instead, use this function with\n * [`execPopulate()`](#document_Document-execPopulate)\n *\n * ####Example:\n *\n *     doc\n *     .populate('company')\n *     .populate({\n *       path: 'notes',\n *       match: /airline/,\n *       select: 'text',\n *       model: 'modelName'\n *       options: opts\n *     }, function (err, user) {\n *       assert(doc._id === user._id) // the document itself is passed\n *     })\n *\n *     // summary\n *     doc.populate(path)                   // not executed\n *     doc.populate(options);               // not executed\n *     doc.populate(path, callback)         // executed\n *     doc.populate(options, callback);     // executed\n *     doc.populate(callback);              // executed\n *     doc.populate(options).execPopulate() // executed, returns promise\n *\n *\n * ####NOTE:\n *\n * Population does not occur unless a `callback` is passed *or* you explicitly\n * call `execPopulate()`.\n * Passing the same path a second time will overwrite the previous path options.\n * See [Model.populate()](#model_Model.populate) for explaination of options.\n *\n * @see Model.populate #model_Model.populate\n * @see Document.execPopulate #document_Document-execPopulate\n * @param {String|Object} [path] The path to populate or an options object\n * @param {Function} [callback] When passed, population is invoked\n * @api public\n * @return {Document} this\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.populate = function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  const pop = this.$__.populate || (this.$__.populate = {});\n  const args = utils.args(arguments);\n  let fn;\n\n  if (typeof args[args.length - 1] === 'function') {\n    fn = args.pop();\n  } // allow `doc.populate(callback)`\n\n\n  if (args.length) {\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  if (fn) {\n    const paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    let topLevelModel = this.constructor;\n\n    if (this.$__isNested) {\n      topLevelModel = this.$__[scopeSymbol].constructor;\n      const nestedPath = this.$__.nestedPath;\n      paths.forEach(function (populateOptions) {\n        populateOptions.path = nestedPath + '.' + populateOptions.path;\n      });\n    } // Use `$session()` by default if the document has an associated session\n    // See gh-6754\n\n\n    if (this.$session() != null) {\n      const session = this.$session();\n      paths.forEach(path => {\n        if (path.options == null) {\n          path.options = {\n            session: session\n          };\n          return;\n        }\n\n        if (!('session' in path.options)) {\n          path.options.session = session;\n        }\n      });\n    }\n\n    topLevelModel.populate(this, paths, fn);\n  }\n\n  return this;\n};\n/**\n * Explicitly executes population and returns a promise. Useful for ES2015\n * integration.\n *\n * ####Example:\n *\n *     const promise = doc.\n *       populate('company').\n *       populate({\n *         path: 'notes',\n *         match: /airline/,\n *         select: 'text',\n *         model: 'modelName'\n *         options: opts\n *       }).\n *       execPopulate();\n *\n *     // summary\n *     doc.execPopulate().then(resolve, reject);\n *\n *   // you can also use doc.execPopulate(options) as a shorthand for\n *   // doc.populate(options).execPopulate()\n *\n *\n * ####Example:\n *   const promise = doc.execPopulate({ path: 'company', select: 'employees' });\n *\n *   // summary\n *   promise.then(resolve,reject);\n *\n * @see Document.populate #document_Document-populate\n * @api public\n * @param {Function} [callback] optional callback. If specified, a promise will **not** be returned\n * @return {Promise} promise that resolves to the document when population is done\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.execPopulate = function (callback) {\n  const isUsingShorthand = callback != null && typeof callback !== 'function';\n\n  if (isUsingShorthand) {\n    return this.populate.apply(this, arguments).execPopulate();\n  }\n\n  return promiseOrCallback(callback, cb => {\n    this.populate(cb);\n  }, this.constructor.events);\n};\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, undefined is returned.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.populated = function (path, val, options) {\n  // val and options are internal\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n\n    const v = this.$__.populated[path];\n\n    if (v) {\n      return v.value;\n    }\n\n    return undefined;\n  } // internal\n\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {\n    value: val,\n    options: options\n  }; // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n\n  const pieces = path.split('.');\n\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.get(subpath);\n\n    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.populated(rest, val, options); // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n\n      break;\n    }\n  }\n\n  return val;\n};\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, this is a no-op.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.depopulate = function (path) {\n  if (typeof path === 'string') {\n    path = path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = get(this, '$__.populated', {});\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.populated(key);\n\n      if (!populatedIds) {\n        continue;\n      }\n\n      delete populated[key];\n      this.$set(key, populatedIds);\n    }\n\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      this.$set(singlePath, populatedIds);\n    }\n  }\n\n  return this;\n};\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__fullPath = function (path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.getChanges = function () {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n/*!\n * Module exports.\n */\n\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;","map":{"version":3,"names":["EventEmitter","require","InternalCache","MongooseError","MixedSchema","ObjectExpectedError","ObjectParameterError","ParallelValidateError","Schema","StrictModeError","ValidationError","ValidatorError","VirtualType","promiseOrCallback","cleanModifiedSubpaths","compile","defineKey","flatten","get","getEmbeddedDiscriminatorPath","handleSpreadDoc","idGetter","isDefiningProjection","isExclusive","inspect","internalToObjectOptions","mpath","queryhelpers","utils","isPromise","clone","deepEqual","isMongooseObject","arrayAtomicsBackupSymbol","Symbol","arrayAtomicsSymbol","documentArrayParent","documentIsSelected","documentIsModified","documentModifiedPaths","documentSchemaSymbol","getSymbol","populateModelSymbol","scopeSymbol","DocumentArray","MongooseArray","Embedded","specialProperties","Document","obj","fields","skipId","options","Object","assign","defaults","schema","_schema","isObject","instanceOfSchema","$__setSchema","arguments","$__","emitter","isNew","errors","undefined","$options","$locals","$op","strictMode","strict","selected","requiredPaths","path","activePaths","setMaxListeners","exclude","isPOJO","hasIncludedChildren","$__hasIncludedChildren","_doc","$__buildDoc","$__applyDefaults","$__original_set","$set","willInit","prototype","once","call","skipDefaults","_id","_this","keys","forEach","key","tree","applyQueue","each","emitterFn","apply","constructor","i","defineProperty","configurable","enumerable","writable","id","parts","split","c","part","push","join","doc","isBeforeSetters","pathsToSkip","paths","plen","length","def","curPath","p","type","indexOf","len","included","doc_","j","piece","defaultValue","$runBeforeSetters","getDefault","err","invalidate","default","filter","includes","ii","last","toBSON","toObject","init","opts","fn","$__init","$init","populated","String","item","isVirtual","getValue","_docs","_childDocs","child","parent","markArraySubdocsPopulated","emit","pieces","subpath","slice","rest","val","isMongooseDocumentArray","self","prefix","index","_init","$isRootDiscriminator","isSelected","_castNullish","intCache","wasPopulated","cast","e","message","value","isModified","update","args","unshift","query","$session","session","updateOne","callback","_pre","cb","_middleware","execPre","_post","execPost","exec","replaceOne","ownerDocument","subdocs","$__getAllSubdocs","overwrite","Array","from","Set","concat","versionKey","discriminatorKey","merge","adhoc","constructing","adhocs","pathtype","adhocPaths","interpretAsType","$__isNested","_","_skipMinimizeTopLevel","_handleIndex","$setCalled","add","pathName","pathType","isNativeObject","isMongooseType","$__path","ref","typeOnly","$isSingleNested","virtuals","transform","$__setValue","markModified","skipDocArrays","CastError","aliases","mixed","set","virtualpath","applySetters","cur","unmarkModified","$__getValue","pathToMark","getters","priorVal","priorDoc","$__set","$isMongooseArray","_markValidSubpaths","shouldSet","refMatches","model","modelName","baseModelName","refPath","didPopulate","popOpts","isArray","typeKey","_isManuallyPopulatedArray","$__fullPath","map","v","singleNestedPaths","$isMongooseDocumentArray","populatedPaths","populatedPath","_checkImmutableSubpaths","$markValid","isImmutableError","$originalErrorPath","instance","isDirectModified","el","$__shouldModify","states","shouldModify","isMongooseArray","_registerAtomic","__parentArray","modifiedPath","startsWith","ignore","l","next","has","Map","setValue","virtual","applyGetters","nested","applyVirtuals","adhocType","hasOwnProperty","scope","modify","pathsToScopes","$ignore","directModifiedPaths","$isEmpty","isEmptyOptions","minimize","_isEmpty","modifiedPaths","reduce","list","chains","chain","includeChildren","modified","childPath","isModifiedChild","some","mod","$isDefault","$isDeleted","isDeleted","isInit","inclusive","pathDot","isDirectSelected","validate","pathsToValidate","parallelValidate","validating","parentStack","conflictStack","stack","$__validate","error","events","_evaluateRequiredFunctions","originalRequiredValue","cachedRequired","_getPathsToValidate","skipSchemaValidators","addToPaths","subdoc","$basePath","delete","_pathType","_pushNestedArrayPaths","numElements","flattenOptions","skipArrays","pathToCheck","_v","flat","$isSchemaMap","hasValidateModifiedOnlyOption","shouldValidateModifiedOnly","validateModifiedOnly","_complete","validationError","errPath","pathDetails","_handlePathsToValidate","process","nextTick","s","hooks","validated","total","complete","validatePath","schemaType","$isValid","pop","doValidateOptions","doValidate","$isArrayValidatorError","storeSubdocValidationError","numPaths","_pathsToValidate","parentPaths","ret","validateSync","doValidateSync","kind","addError","schematype","$immutableSetter","oldVal","$__reset","reset","array","$path","$__dirty","dirt","backup","clear","$__undoReset","all","sort","a","b","minimal","lastPath","top","hasAtomics","plugin","deduplicate","_applyDefaultGetters","$__getArrayPathsToValidate","bind","seed","docReducer","_docReduce","subDocs","q","callQueue","pair","$__handleReject","handleReject","listeners","$toObject","json","defaultOptions","flattenDecimals","baseOptions","schemaOptions","_calledWithOptions","flattenMaps","_minimize","cloneOptions","_isNested","hasUserDefinedProperty","depopulate","_parentOptions","_skipSingleNestedGetters","gettersOptions","originalTransform","applySchemaTypeTransforms","useProjection","omitDeselectedFields","toJSON","xformed","hasKeys","Buffer","isBuffer","toObjectOptions","assignPath","substr","branch","transformedValue","throwErrorIfPromise","$embeddedSchemaType","vals","Error","applyPaths","custom","toString","equals","tid","docid","populate","res","populateOptions","object","topLevelModel","nestedPath","execPopulate","isUsingShorthand","populatedIds","virtualKeys","$$populatedVirtuals","virtualKey","singlePath","getChanges","delta","$__delta","changes","module","exports"],"sources":["/Users/juliachu/Dropbox/CS/market/node_modules/mongoose/lib/document.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst InternalCache = require('./internal');\nconst MongooseError = require('./error/index');\nconst MixedSchema = require('./schema/mixed');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst ObjectParameterError = require('./error/objectParameter');\nconst ParallelValidateError = require('./error/parallelValidate');\nconst Schema = require('./schema');\nconst StrictModeError = require('./error/strict');\nconst ValidationError = require('./error/validation');\nconst ValidatorError = require('./error/validator');\nconst VirtualType = require('./virtualtype');\nconst promiseOrCallback = require('./helpers/promiseOrCallback');\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\nconst compile = require('./helpers/document/compile').compile;\nconst defineKey = require('./helpers/document/compile').defineKey;\nconst flatten = require('./helpers/common').flatten;\nconst get = require('./helpers/get');\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\nconst handleSpreadDoc = require('./helpers/document/handleSpreadDoc');\nconst idGetter = require('./plugins/idGetter');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst isExclusive = require('./helpers/projection/isExclusive');\nconst inspect = require('util').inspect;\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst mpath = require('mpath');\nconst queryhelpers = require('./queryhelpers');\nconst utils = require('./utils');\nconst isPromise = require('./helpers/isPromise');\n\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = Symbol('mongoose.Array#atomicsBackup');\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\nconst documentIsSelected = require('./helpers/symbols').documentIsSelected;\nconst documentIsModified = require('./helpers/symbols').documentIsModified;\nconst documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\nconst getSymbol = require('./helpers/symbols').getSymbol;\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\nconst scopeSymbol = require('./helpers/symbols').scopeSymbol;\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n  const defaults = get(options, 'defaults', true);\n  options.defaults = defaults;\n\n  // Support `browserDocument.js` syntax\n  if (this.schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\n      new Schema(fields) :\n      fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache;\n  this.$__.emitter = new EventEmitter();\n  this.isNew = 'isNew' in options ? options.isNew : true;\n  this.errors = undefined;\n  this.$__.$options = options || {};\n  this.$locals = {};\n  this.$op = null;\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  const schema = this.schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields)) {\n    exclude = isExclusive(fields);\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    {};\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {\n        isNew: this.isNew\n      });\n    }\n  }\n\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true);\n    } else {\n      this.$set(obj, undefined, true);\n    }\n\n    if (obj instanceof Document) {\n      this.isNew = obj.isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    EventEmitter.prototype.once.call(this, 'init', () => {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n        isNew: this.isNew\n      });\n    });\n  } else if (defaults) {\n    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n      isNew: this.isNew\n    });\n  }\n\n  this.$__._id = this._id;\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      if (!(key in schema.tree)) {\n        defineKey(key, null, _this);\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n  });\n\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The documents schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * ####Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.errors;\n\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * ####Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$op;\n\n/*!\n * ignore\n */\n\nfunction $__hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n\n  for (const key of keys) {\n    const parts = key.split('.');\n    const c = [];\n\n    for (const part of parts) {\n      c.push(part);\n      hasIncludedChildren[c.join('.')] = 1;\n    }\n  }\n\n  return hasIncludedChildren;\n}\n\n/*!\n * ignore\n */\n\nfunction $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && skipId) {\n      continue;\n    }\n\n    const type = doc.schema.paths[p];\n    const path = p.indexOf('.') === -1 ? [p] : p.split('.');\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (typeof type.defaultValue === 'function') {\n          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n            break;\n          }\n          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n            break;\n          }\n        } else if (!isBeforeSetters) {\n          // Non-function defaults should always run **before** setters\n          continue;\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            doc.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = p.split('.');\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.isNew = false;\n  this.$init = true;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n\n  markArraySubdocsPopulated(this, opts.populated);\n\n  this.emit('init', this);\n  this.constructor.emit('init', this);\n\n  this.$__._id = this._id;\n\n  return this;\n};\n\n/*!\n * If populating a path within a document array, make sure each\n * subdoc within the array knows its subpaths are populated.\n *\n * ####Example:\n *     const doc = await Article.findOne().populate('comments.author');\n *     doc.comments[0].populated('author'); // Should be set\n */\n\nfunction markArraySubdocsPopulated(doc, populated) {\n  if (doc._id == null || populated == null || populated.length === 0) {\n    return;\n  }\n\n  const id = String(doc._id);\n  for (const item of populated) {\n    if (item.isVirtual) {\n      continue;\n    }\n    const path = item.path;\n    const pieces = path.split('.');\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const rest = pieces.slice(i + 1).join('.');\n      const val = doc.get(subpath);\n      if (val == null) {\n        continue;\n      }\n\n      if (val.isMongooseDocumentArray) {\n        for (let j = 0; j < val.length; ++j) {\n          val[j].populated(rest, item._docs[id] == null ? [] : item._docs[id][j], item);\n        }\n        break;\n      }\n    }\n  }\n}\n\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schema;\n  let path;\n  let i;\n  let index = 0;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.schema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (self.schema.$isRootDiscriminator && !self.isSelected(path)) {\n      return;\n    }\n\n    if (!schema && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schema) {\n      doc[i] = obj[i];\n    } else {\n      if (obj[i] === null) {\n        doc[i] = schema._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const intCache = obj[i].$__ || {};\n        const wasPopulated = intCache.wasPopulated || null;\n\n        if (schema && !wasPopulated) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.update = function update() {\n  const args = utils.args(arguments);\n  args.unshift({ _id: this._id });\n  const query = this.constructor.update.apply(this.constructor, args);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  return query;\n};\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model.updateOne)\n *\n * @see Model.updateOne #model_Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({ _id: this._id }, doc, options);\n  query._pre(cb => {\n    this.constructor._middleware.execPre('updateOne', this, [this], cb);\n  });\n  query._post(cb => {\n    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * ####Valid options:\n *\n *  - same as in [Model.replaceOne](#model_Model.replaceOne)\n *\n * @see Model.replaceOne #model_Model.replaceOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = utils.args(arguments);\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * ####Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    return this.$__.session;\n  }\n  this.$__.session = session;\n\n  if (!this.ownerDocument) {\n    const subdocs = this.$__getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @name overwrite\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.schema.options.versionKey && key === this.schema.options.versionKey) {\n      continue;\n    }\n    if (this.schema.options.discriminatorKey && key === this.schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @method $set\n * @name $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  options = options || {};\n  const merge = options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const strict = 'strict' in options\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n\n    if (path == null) {\n      const _ = path;\n      path = val;\n      val = _;\n    } else {\n      prefix = val ? val + '.' : '';\n\n      keys = Object.keys(path);\n      const len = keys.length;\n\n      // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n      // nested key to ensure key order.\n      const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);\n      if (len === 0 && _skipMinimizeTopLevel) {\n        delete options._skipMinimizeTopLevel;\n        if (val) {\n          this.$set(val, {});\n        }\n        return this;\n      }\n\n      while (i < len) {\n        _handleIndex.call(this, i++);\n      }\n\n      return this;\n    }\n  } else {\n    this.$__.$setCalled.add(path);\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    const pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    // On initial set, delete any nested keys if we're going to overwrite\n    // them to ensure we keep the user's key order.\n    if (type === true &&\n        !prefix &&\n        path[key] != null &&\n        pathtype === 'nested' &&\n        this._doc[key] != null &&\n        Object.keys(this._doc[key]).length === 0) {\n      delete this._doc[key];\n      // Make sure we set `{}` back even if we minimize re: gh-8565\n      options = Object.assign({}, options, { _skipMinimizeTopLevel: true });\n    }\n\n    if (typeof path[key] === 'object' &&\n        !utils.isNativeObject(path[key]) &&\n        !utils.isMongooseType(path[key]) &&\n        path[key] != null &&\n        pathtype !== 'virtual' &&\n        pathtype !== 'real' &&\n        pathtype !== 'adhocOrUndefined' &&\n        !(this.$__path(pathName) instanceof MixedSchema) &&\n        !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.$__.$setCalled.add(prefix + key);\n      this.$set(path[key], prefix + key, constructing, options);\n    } else if (strict) {\n      // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n      if (constructing && path[key] === void 0 &&\n          this.get(pathName) !== void 0) {\n        return;\n      }\n\n      if (pathtype === 'adhocOrUndefined') {\n        pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n      }\n\n      if (pathtype === 'real' || pathtype === 'virtual') {\n        // Check for setting single embedded schema to document (gh-3535)\n        let p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.$set(prefix + key, p, constructing, options);\n      } else if (pathtype === 'nested' && path[key] instanceof Document) {\n        this.$set(prefix + key,\n          path[key].toObject({ transform: false }), constructing, options);\n      } else if (strict === 'throw') {\n        if (pathtype === 'nested') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.$set(prefix + key, path[key], constructing, options);\n    }\n  }\n\n  let pathType = this.schema.pathType(path);\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val);\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = Object.keys(val);\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing);\n      }\n      this.markModified(path);\n      cleanModifiedSubpaths(this, path, { skipDocArrays: true });\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  // Might need to change path for top-level alias\n  if (typeof this.schema.aliases[parts[0]] == 'string') {\n    parts[0] = this.schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length > 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.get(subpath, null, { getters: false }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.$options.priorDoc != null) {\n      return this.$__.$options.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (schema.$isSingleNested && val != null && merge) {\n    if (val instanceof Document) {\n      val = val.toObject({ virtuals: false, transform: false });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document) {\n      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });\n      didPopulate = true;\n    }\n\n    let popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options[this.schema.options.typeKey]) &&\n        schema.options[this.schema.options.typeKey].length &&\n        schema.options[this.schema.options.typeKey][0].ref &&\n        _isManuallyPopulatedArray(val, schema.options[this.schema.options.typeKey][0].ref)) {\n      if (this.ownerDocument) {\n        popOpts = { [populateModelSymbol]: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { [populateModelSymbol]: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n\n    if (this.schema.singleNestedPaths[path] == null) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      val = schema.applySetters(val, this, false, priorVal);\n    }\n\n    if (schema.$isMongooseDocumentArray &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] != null &&\n        val[0].$__ != null &&\n        val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.populated(path + '.' + populatedPath,\n          val.map(v => v.populated(populatedPath)),\n          val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val[i] = val[i]._id;\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n\n    if (schema.$isSingleNested && val != null) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path,\n          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path,\n        new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n  if (this.schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n\n  if (val === void 0 && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/embedded');\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  const _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.startsWith(path + '.')) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\nDocument.prototype.$__getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\nDocument.prototype.$__setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  options = options || {};\n  if (type) {\n    adhoc = this.schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  let schema = this.$__path(path);\n  if (schema == null) {\n    schema = this.schema.virtualpath(path);\n  }\n  if (schema instanceof MixedSchema) {\n    const virtual = this.schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n  const pieces = path.split('.');\n  let obj = this._doc;\n\n  if (schema instanceof VirtualType) {\n    if (schema.getters.length === 0) {\n      return void 0;\n    }\n    return schema.applyGetters(null, this);\n  }\n\n  // Might need to change path for top-level alias\n  if (typeof this.schema.aliases[pieces[0]] == 'string') {\n    pieces[0] = this.schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], { getters: false });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });\n  }\n\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.ownerDocument) {\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  delete this.$__.pathsToScopes[path];\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * ####Example\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function() {\n  return Object.keys(this.$__.activePaths.states.modify);\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * ####Example:\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function(path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length > 0) {\n    const v = this.get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  const _this = this;\n  return directModifiedPaths.reduce(function(list, path) {\n    const parts = path.split('.');\n    list = list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n\n    if (!options.includeChildren) {\n      return list;\n    }\n\n    let cur = _this.get(path);\n    if (cur != null && typeof cur === 'object') {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      if (Array.isArray(cur)) {\n        const len = cur.length;\n        for (let i = 0; i < len; ++i) {\n          if (list.indexOf(path + '.' + i) === -1) {\n            list.push(path + '.' + i);\n            if (cur[i] != null && cur[i].$__) {\n              const modified = cur[i].modifiedPaths();\n              for (const childPath of modified) {\n                list.push(path + '.' + i + '.' + childPath);\n              }\n            }\n          }\n        }\n      } else {\n        Object.keys(cur).\n          filter(function(key) {\n            return list.indexOf(path + '.' + key) === -1;\n          }).\n          forEach(function(key) {\n            list.push(path + '.' + key);\n          });\n      }\n    }\n\n    return list;\n  }, []);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\n * Returns true if this document was modified, else false.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, modifiedPaths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  return (path in this.$__.activePaths.states.default);\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * ####Example:\n *     product.remove(function (err, product) {\n *       product.$isDeleted(); // true\n *       product.remove(); // no-op, doesn't send anything to the db\n *\n *       product.$isDeleted(false);\n *       product.$isDeleted(); // false\n *       product.remove(); // will execute a remove against the db\n *     })\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  return (path in this.$__.activePaths.states.modify);\n};\n\n/**\n * Checks if `path` was initialized.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  return (path in this.$__.activePaths.states.init);\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     Thing.findOne().select('name').exec(function (err, doc) {\n *        doc.isSelected('name') // true\n *        doc.isSelected('age')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    const paths = Object.keys(this.$__.selected);\n    let i = paths.length;\n    let inclusive = null;\n    let cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n      if (!isDefiningProjection(this.$__.selected[cur])) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    const pathDot = path + '.';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (cur.startsWith(pathDot)) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.startsWith(cur + '.')) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n\nDocument.prototype[documentIsSelected] = Document.prototype.isSelected;\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * ####Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    const paths = Object.keys(this.$__.selected);\n    let i = paths.length;\n    let inclusive = null;\n    let cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n      if (!isDefiningProjection(this.$__.selected[cur])) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\nDocument.prototype.validate = function(pathsToValidate, options, callback) {\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.ownerDocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });\n  }\n\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = pathsToValidate;\n    pathsToValidate = null;\n  }\n\n  return promiseOrCallback(callback, cb => {\n    if (parallelValidate != null) {\n      return cb(parallelValidate);\n    }\n\n    this.$__validate(pathsToValidate, options, (error) => {\n      this.$op = null;\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  Object.keys(doc.$__.activePaths.states.require).forEach(path => {\n    const p = doc.schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n    }\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc) {\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc);\n\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function(path) {\n    if (!doc.isSelected(path) && !doc.isModified(path)) {\n      return false;\n    }\n    if (path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n\n\n  Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);\n  function addToPaths(p) { paths.add(p); }\n\n  const subdocs = doc.$__getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc\n      for (const p of paths) {\n        if (p === null || p.startsWith(subdoc.$basePath + '.')) {\n          paths.delete(p);\n        }\n      }\n\n      if (doc.isModified(subdoc.$basePath, modifiedPaths) &&\n            !doc.isDirectModified(subdoc.$basePath) &&\n            !doc.$isDefault(subdoc.$basePath)) {\n        paths.add(subdoc.$basePath);\n\n        skipSchemaValidators[subdoc.$basePath] = true;\n      }\n    }\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (const path of paths) {\n    const _pathType = doc.schema.path(path);\n    if (!_pathType ||\n        !_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (_pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required'))) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = { skipArrays: true };\n  for (const pathToCheck of paths) {\n    if (doc.schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n    const _pathType = doc.schema.path(path);\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, skipSchemaValidators];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = undefined;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    this.$__.validating = null;\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] &&\n            validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  }\n\n  if (paths.length === 0) {\n    return process.nextTick(function() {\n      const error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  const complete = function() {\n    const error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  };\n\n  const validatePath = function(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      const schemaType = _this.schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if (val == null && (pop = _this.populated(path))) {\n        val = pop;\n      }\n      const scope = path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      const doValidateOptions = {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path\n      };\n      schemaType.doValidate(val, function(err) {\n        if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n          if (schemaType.$isSingleNested &&\n              err instanceof ValidationError &&\n              schemaType.schema.options.storeSubdocValidationError === false) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  };\n\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    validatePath(paths[i]);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = [];\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.push(path);\n    } else if (parentPaths.has(path)) {\n      ret.push(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate, options) {\n  const _this = this;\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;\n  }\n\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  }\n\n  const validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    const p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path\n    });\n    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n      if (p.$isSingleNested &&\n          err instanceof ValidationError &&\n          p.schema.options.storeSubdocValidationError === false) {\n        return;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](/docs/api.html#document_Document-isNew) is `true`,\n * or sends an [updateOne](/docs/api.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * ####Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](api.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String} path the field to check\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return _this.$__getValue(i);\n    })\n    .filter(function(val) {\n      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n    })\n    .forEach(function(array) {\n      let i = array.length;\n      while (i--) {\n        const doc = array[i];\n        if (!doc) {\n          continue;\n        }\n        doc.$__reset();\n      }\n\n      _this.$__.activePaths.init(array.$path());\n\n      array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n      array[arrayAtomicsSymbol] = {};\n    });\n\n  this.$__.activePaths.\n    map('init', 'modify', function(i) {\n      return _this.$__getValue(i);\n    }).\n    filter(function(val) {\n      return val && val.$isSingleNested;\n    }).\n    forEach(function(doc) {\n      doc.$__reset();\n      _this.$__.activePaths.init(doc.$basePath);\n    });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.states.modify),\n    default: Object.assign({}, this.$__.activePaths.states.default)\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n\n  this.$__.validationError = this.$__.backup.validationError;\n  this.errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$__getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n  let lastPath;\n  let top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + '.';\n      minimal.push(item);\n      top = item;\n    } else if (top != null &&\n        top.value != null &&\n        top.value[arrayAtomicsSymbol] != null &&\n        top.value.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being modified.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top.value[arrayAtomicsSymbol] = {};\n      top.value[arrayAtomicsSymbol].$set = top.value;\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  schema.plugin(idGetter, { deduplicate: true });\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n\n  this.schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.$__getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @api private\n * @method $__getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  Embedded = Embedded || require('./types/embedded');\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val._doc, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      seed = Object.keys(val).reduce(function(seed, path) {\n        return docReducer(val, seed, path);\n      }, seed);\n    }\n    return seed;\n  }\n\n  const _this = this;\n  const subDocs = Object.keys(this._doc).reduce(function(seed, path) {\n    return docReducer(_this, seed, path);\n  }, []);\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.schema && doc.schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners('error').length) {\n    this.emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = get(this, 'constructor.base.options.' + path, {});\n  const schemaOptions = get(this, 'schema.options', {});\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? clone(options) : {};\n  options._calledWithOptions = options._calledWithOptions || clone(options);\n\n  if (!('flattenMaps' in options)) {\n    options.flattenMaps = defaultOptions.flattenMaps;\n  }\n\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign(utils.clone(options), {\n    _isNested: true,\n    json: json,\n    minimize: _minimize\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate ||\n    get(options, '_parentOptions.depopulate', false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = true;\n\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = false;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain javascript object, ready for storage in MongoDB.\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters), defaults to false\n * - `aliases` apply all aliases if `virtuals=true`, defaults to true\n * - `virtuals` apply virtual getters (can override `getters` option), defaults to false\n * - `minimize` remove empty objects, defaults to true\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs, defaults to false\n * - `versionKey` whether to include the version key, defaults to true\n * - `flattenMaps` convert Maps to POJOs. Useful if you want to JSON.stringify() the result of toObject(), defaults to false\n * - `useProjection` set to `true` to omit fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this is behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isObject(val) && !Buffer.isBuffer(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = get(toObjectOptions, 'aliases', true);\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substr(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        const val = self.get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/*!\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.get(path);\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      json[path] = transformedValue;\n    } else if (schematype.$embeddedSchemaType != null &&\n        typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const vals = [].concat(self.get(path));\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns `undefined` otherwise.\n *\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.parent = function() {\n  return this.$__.parent;\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if the Document stores the same data as doc.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates document references, executing the `callback` when complete.\n * If you want to use promises instead, use this function with\n * [`execPopulate()`](#document_Document-execPopulate)\n *\n * ####Example:\n *\n *     doc\n *     .populate('company')\n *     .populate({\n *       path: 'notes',\n *       match: /airline/,\n *       select: 'text',\n *       model: 'modelName'\n *       options: opts\n *     }, function (err, user) {\n *       assert(doc._id === user._id) // the document itself is passed\n *     })\n *\n *     // summary\n *     doc.populate(path)                   // not executed\n *     doc.populate(options);               // not executed\n *     doc.populate(path, callback)         // executed\n *     doc.populate(options, callback);     // executed\n *     doc.populate(callback);              // executed\n *     doc.populate(options).execPopulate() // executed, returns promise\n *\n *\n * ####NOTE:\n *\n * Population does not occur unless a `callback` is passed *or* you explicitly\n * call `execPopulate()`.\n * Passing the same path a second time will overwrite the previous path options.\n * See [Model.populate()](#model_Model.populate) for explaination of options.\n *\n * @see Model.populate #model_Model.populate\n * @see Document.execPopulate #document_Document-execPopulate\n * @param {String|Object} [path] The path to populate or an options object\n * @param {Function} [callback] When passed, population is invoked\n * @api public\n * @return {Document} this\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.populate = function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  const pop = this.$__.populate || (this.$__.populate = {});\n  const args = utils.args(arguments);\n  let fn;\n\n  if (typeof args[args.length - 1] === 'function') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  if (fn) {\n    const paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    let topLevelModel = this.constructor;\n    if (this.$__isNested) {\n      topLevelModel = this.$__[scopeSymbol].constructor;\n      const nestedPath = this.$__.nestedPath;\n      paths.forEach(function(populateOptions) {\n        populateOptions.path = nestedPath + '.' + populateOptions.path;\n      });\n    }\n\n    // Use `$session()` by default if the document has an associated session\n    // See gh-6754\n    if (this.$session() != null) {\n      const session = this.$session();\n      paths.forEach(path => {\n        if (path.options == null) {\n          path.options = { session: session };\n          return;\n        }\n        if (!('session' in path.options)) {\n          path.options.session = session;\n        }\n      });\n    }\n\n    topLevelModel.populate(this, paths, fn);\n  }\n\n  return this;\n};\n\n/**\n * Explicitly executes population and returns a promise. Useful for ES2015\n * integration.\n *\n * ####Example:\n *\n *     const promise = doc.\n *       populate('company').\n *       populate({\n *         path: 'notes',\n *         match: /airline/,\n *         select: 'text',\n *         model: 'modelName'\n *         options: opts\n *       }).\n *       execPopulate();\n *\n *     // summary\n *     doc.execPopulate().then(resolve, reject);\n *\n *   // you can also use doc.execPopulate(options) as a shorthand for\n *   // doc.populate(options).execPopulate()\n *\n *\n * ####Example:\n *   const promise = doc.execPopulate({ path: 'company', select: 'employees' });\n *\n *   // summary\n *   promise.then(resolve,reject);\n *\n * @see Document.populate #document_Document-populate\n * @api public\n * @param {Function} [callback] optional callback. If specified, a promise will **not** be returned\n * @return {Promise} promise that resolves to the document when population is done\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.execPopulate = function(callback) {\n  const isUsingShorthand = callback != null && typeof callback !== 'function';\n  if (isUsingShorthand) {\n    return this.populate.apply(this, arguments).execPopulate();\n  }\n\n  return promiseOrCallback(callback, cb => {\n    this.populate(cb);\n  }, this.constructor.events);\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, undefined is returned.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    const v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n\n  return val;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, this is a no-op.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = get(this, '$__.populated', {});\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      this.$set(key, populatedIds);\n    }\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      this.$set(singlePath, populatedIds);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.getChanges = function() {\n  const delta = this.$__delta();\n\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n"],"mappings":"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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEApU,QAAQ,CAACuC,SAAT,CAAmBsD,QAAnB,GAA8B,UAASzF,OAAT,EAAkB;EAC9C,OAAO,KAAKwW,SAAL,CAAexW,OAAf,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASsP,QAAT,CAAkBzP,GAAlB,EAAuB;EACrB,MAAM4C,IAAI,GAAGxC,MAAM,CAACwC,IAAP,CAAY5C,GAAZ,CAAb;EACA,IAAIqD,CAAC,GAAGT,IAAI,CAAC0B,MAAb;EACA,IAAI2T,OAAJ;EACA,IAAInV,GAAJ;EACA,IAAImE,GAAJ;;EAEA,OAAO5D,CAAC,EAAR,EAAY;IACVP,GAAG,GAAGF,IAAI,CAACS,CAAD,CAAV;IACA4D,GAAG,GAAGjH,GAAG,CAAC8C,GAAD,CAAT;;IAEA,IAAInE,KAAK,CAAC8B,QAAN,CAAewG,GAAf,KAAuB,CAACiR,MAAM,CAACC,QAAP,CAAgBlR,GAAhB,CAA5B,EAAkD;MAChDjH,GAAG,CAAC8C,GAAD,CAAH,GAAW2M,QAAQ,CAACxI,GAAD,CAAnB;IACD;;IAED,IAAIhG,SAAS,KAAKjB,GAAG,CA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"},"metadata":{},"sourceType":"script"}