{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\n\nconst $type = require('./operators/type');\n\nconst MongooseError = require('../error/mongooseError');\n\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\n\nconst SchemaType = require('../schematype');\n\nconst CastError = SchemaType.CastError;\n\nconst Mixed = require('./mixed');\n\nconst arrayDepth = require('../helpers/arrayDepth');\n\nconst cast = require('../cast');\n\nconst get = require('../helpers/get');\n\nconst isOperator = require('../helpers/query/isOperator');\n\nconst util = require('util');\n\nconst utils = require('../utils');\n\nconst castToNumber = require('./operators/helpers').castToNumber;\n\nconst geospatial = require('./operators/geospatial');\n\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n  let typeKey = 'type';\n\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    } // support { type: 'String' }\n\n\n    const name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' && !caster.$isArraySubdocument && !caster.$isSchemaMap) {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    this.$embeddedSchemaType = this.caster;\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  this.$isMongooseArray = true;\n  SchemaType.call(this, key, options, 'Array');\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function () {\n      let arr = [];\n\n      if (fn) {\n        arr = defaultArr.call(this);\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      } // Leave it up to `cast()` to convert the array\n\n\n      return arr;\n    };\n\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nSchemaArray.schemaName = 'Array';\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = {\n  castNonArrays: true\n};\nSchemaArray.defaultOptions = {};\n/**\n * Sets a default option for all Array instances.\n *\n * ####Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaArray.set = SchemaType.set;\n/*!\n * Inherits from SchemaType.\n */\n\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  } // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n\n\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ? this.constructor.checkRequired() : SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaArray} this\n */\n\n\nSchemaArray.prototype.enum = function () {\n  let arr = this;\n\n  while (true) {\n    const instance = get(arr, 'caster.instance');\n\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' + ', not ' + instance);\n    }\n\n    break;\n  }\n\n  arr.caster.enum.apply(arr.caster, arguments);\n  return this;\n};\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\nSchemaArray.prototype._applySetters = function (value, scope, init, priorVal) {\n  if (this.casterConstructor instanceof SchemaArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n\n    while (arr != null && arr instanceof SchemaArray && !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    } // No need to wrap empty arrays\n\n\n    if (value != null && value.length > 0) {\n      const valueDepth = arrayDepth(value);\n\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\n\nSchemaArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      const indexes = doc.schema.indexedPaths();\n      const arrayPath = this.path;\n\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      } // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n\n\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ? this.path.substr(0, this.path.lastIndexOf('.')) : null;\n\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this._arrayPath || this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this._arrayPath || this.path, doc);\n    }\n\n    const isPopulated = doc != null && doc.$__ != null && doc.populated(this.path);\n\n    if (isPopulated) {\n      return value;\n    }\n\n    if (this.caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          // Special case: number arrays disallow undefined.\n          // Re: gh-840\n          // See commit 1298fe92d2c790a90594bd08199e45a4a09162a6\n          if (this.caster.instance === 'Number' && value[i] === void 0) {\n            throw new MongooseError('Mongoose number arrays disallow storing undefined');\n          }\n\n          const opts = {};\n\n          if (options != null && options.arrayPath != null) {\n            opts.arrayPath = options.arrayPath + '.' + i;\n          } else if (this.caster._arrayPath != null) {\n            opts.arrayPath = this.caster._arrayPath.slice(0, -2) + '.' + i;\n          }\n\n          value[i] = this.caster.cast(value[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n/*!\n * Ignore\n */\n\n\nSchemaArray.prototype.discriminator = function (name, schema) {\n  let arr = this; // eslint-disable-line consistent-this\n\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' + 'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n\n  return arr.discriminator(name, schema);\n};\n/*!\n * ignore\n */\n\n\nSchemaArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n\n  return schematype;\n};\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\n\nSchemaArray.prototype.castForQuery = function ($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor, val[Constructor.schema.options.discriminatorKey]);\n\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function (v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function (v) {\n    if (utils.isObject(v)) {\n      const o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n\n    return v;\n  }, this);\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value);\n    }\n  } // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n\n\n  const discriminatorKey = get(this, 'casterConstructor.schema.options.discriminatorKey');\n  const discriminators = get(this, 'casterConstructor.schema.discriminators', {});\n\n  if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\n\nhandle.$or = handle.$and = function (val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  const ret = [];\n\n  for (const obj of val) {\n    ret.push(cast(this.casterConstructor.schema, obj));\n  }\n\n  return ret;\n};\n\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$exists = $exists;\nhandle.$type = $type;\nhandle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$regex = SchemaArray.prototype.castForQuery; // `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\n\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"names":["$exists","require","$type","MongooseError","SchemaArrayOptions","SchemaType","CastError","Mixed","arrayDepth","cast","get","isOperator","util","utils","castToNumber","geospatial","getDiscriminatorByValue","MongooseArray","EmbeddedDoc","isNestedArraySymbol","Symbol","SchemaArray","key","options","schemaOptions","Embedded","typeKey","castOptions","isPOJO","clone","Object","name","getFunctionName","Types","caster","hasOwnProperty","casterConstructor","$isArraySubdocument","$isSchemaMap","$embeddedSchemaType","path","$isMongooseArray","call","defaultArr","fn","defaultValue","defaultFn","arr","concat","$runBeforeSetters","default","schemaName","castNonArrays","defaultOptions","set","prototype","create","constructor","OptionsConstructor","_checkRequired","checkRequired","value","doc","_isRef","enum","instance","Error","apply","arguments","applyGetters","scope","ref","_applySetters","init","priorVal","depth","$isMongooseDocumentArray","length","valueDepth","min","max","containsNonArrayItem","i","prev","Array","l","isArray","indexes","schema","indexedPaths","arrayPath","pathIndex","arrayGeojsonPath","endsWith","substr","lastIndexOf","isMongooseArray","_arrayPath","isPopulated","$__","populated","opts","slice","e","kind","inspect","markModified","discriminator","assign","schematype","validators","requiredValidator","undefined","castForQuery","$conditional","handler","val","$conditionalHandlers","Constructor","discriminators","discriminatorKey","constructorByValue","proto","method","setters","reverse","forEach","setter","map","v","isObject","$elemMatch","cast$all","o","cast$elemMatch","keys","numKeys","handle","$all","$options","String","$geoIntersects","cast$geoIntersects","$or","$and","TypeError","ret","obj","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$lt","$lte","$ne","$regex","$nin","$in","module","exports"],"sources":["/Users/juliachu/Dropbox/CS/market/node_modules/mongoose/lib/schema/array.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst get = require('../helpers/get');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    this.$embeddedSchemaType = this.caster;\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      let arr = [];\n      if (fn) {\n        arr = defaultArr.call(this);\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      }\n      // Leave it up to `cast()` to convert the array\n      return arr;\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * ####Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = get(arr, 'caster.instance');\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n  arr.caster.enum.apply(arr.caster, arguments);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor instanceof SchemaArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr instanceof SchemaArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length > 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substr(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this._arrayPath || this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this._arrayPath || this.path, doc);\n    }\n\n    const isPopulated = doc != null && doc.$__ != null && doc.populated(this.path);\n    if (isPopulated) {\n      return value;\n    }\n\n    if (this.caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          // Special case: number arrays disallow undefined.\n          // Re: gh-840\n          // See commit 1298fe92d2c790a90594bd08199e45a4a09162a6\n          if (this.caster.instance === 'Number' && value[i] === void 0) {\n            throw new MongooseError('Mongoose number arrays disallow storing undefined');\n          }\n          const opts = {};\n          if (options != null && options.arrayPath != null) {\n            opts.arrayPath = options.arrayPath + '.' + i;\n          } else if (this.caster._arrayPath != null) {\n            opts.arrayPath = this.caster._arrayPath.slice(0, -2) + '.' + i;\n          }\n          value[i] = this.caster.cast(value[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * Ignore\n */\n\nSchemaArray.prototype.discriminator = function(name, schema) {\n  let arr = this; // eslint-disable-line consistent-this\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(name, schema);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor, val[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function(v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function(v) {\n    if (utils.isObject(v)) {\n      const o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n    return v;\n  }, this);\n\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = get(this,\n    'casterConstructor.schema.options.discriminatorKey');\n  const discriminators = get(this, 'casterConstructor.schema.discriminators', {});\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = handle.$and = function(val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  const ret = [];\n  for (const obj of val) {\n    ret.push(cast(this.casterConstructor.schema, obj));\n  }\n\n  return ret;\n};\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$ne =\nhandle.$regex = SchemaArray.prototype.castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}