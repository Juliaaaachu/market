{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst ArrayType = require('./array');\n\nconst CastError = require('../error/cast');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst SchemaDocumentArrayOptions = require('../options/SchemaDocumentArrayOptions');\n\nconst SchemaType = require('../schematype');\n\nconst ValidationError = require('../error/validation');\n\nconst discriminator = require('../helpers/model/discriminator');\n\nconst get = require('../helpers/get');\n\nconst handleIdOption = require('../helpers/schema/handleIdOption');\n\nconst util = require('util');\n\nconst utils = require('../utils');\n\nconst getConstructor = require('../helpers/discriminator/getConstructor');\n\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\n\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArrayPath(key, schema, options, schemaOptions) {\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n\n  EmbeddedDocument.prototype.$basePath = key;\n  ArrayType.call(this, key, EmbeddedDocument, options);\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n  EmbeddedDocument.base = schema.base;\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function () {\n      let arr = fn.call(this);\n\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      } // Leave it up to `cast()` to convert this to a documentarray\n\n\n      return arr;\n    });\n  }\n\n  const parentSchemaType = this;\n  this.$embeddedSchemaType = new SchemaType(key + '.$', {\n    required: get(this, 'schemaOptions.required', false)\n  });\n\n  this.$embeddedSchemaType.cast = function (value, doc, init) {\n    return parentSchemaType.cast(value, doc, init)[0];\n  };\n\n  this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nDocumentArrayPath.schemaName = 'DocumentArray';\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nDocumentArrayPath.options = {\n  castNonArrays: true\n};\n/*!\n * Inherits from ArrayType.\n */\n\nDocumentArrayPath.prototype = Object.create(ArrayType.prototype);\nDocumentArrayPath.prototype.constructor = DocumentArrayPath;\nDocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/embedded')); // compile an embedded document for this schema\n\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    this.$session(this.ownerDocument().$session());\n  }\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter(); // apply methods\n\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  } // apply statics\n\n\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n  return EmbeddedDocument;\n}\n/**\n * Adds a discriminator to this document array.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {String} [value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @see discriminators /docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\n\nDocumentArrayPath.prototype.discriminator = function (name, schema, tiedValue) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {// Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n  return this.casterConstructor.discriminators[name];\n};\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\n\nDocumentArrayPath.prototype.doValidate = function (array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  const _this = this;\n\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    err.$isArrayValidatorError = true;\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      err.$isArrayValidatorError = true;\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n\n    if (options && options.updateValidator) {\n      return fn();\n    }\n\n    if (!array.isMongooseDocumentArray) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    } // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n\n        if (!(error instanceof ValidationError)) {\n          error.$isArrayValidatorError = true;\n        }\n      }\n\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      } // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n\n\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\n\nDocumentArrayPath.prototype.doValidateSync = function (array, scope) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n\n  if (schemaTypeError != null) {\n    schemaTypeError.$isArrayValidatorError = true;\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  } // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n\n    if (!doc) {\n      continue;\n    } // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n\n\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n/*!\n * ignore\n */\n\n\nDocumentArrayPath.prototype.getDefault = function (scope) {\n  let ret = typeof this.defaultValue === 'function' ? this.defaultValue.call(scope) : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  } // lazy load\n\n\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n\n    const _subdoc = new Constructor({}, ret, undefined, undefined, i);\n\n    _subdoc.init(ret[i]);\n\n    _subdoc.isNew = true; // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\n\nDocumentArrayPath.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray')); // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n  const _opts = {\n    transform: false,\n    virtuals: false\n  };\n  options = options || {};\n\n  if (!Array.isArray(value)) {\n    if (!init && !DocumentArrayPath.options.castNonArrays) {\n      throw new CastError('DocumentArray', util.inspect(value), this.path, null, this);\n    } // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n\n\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  if (!(value && value.isMongooseDocumentArray) && !options.skipDocumentArrayCast) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  if (options.arrayPath != null) {\n    value[arrayPathSymbol] = options.arrayPath;\n  }\n\n  const len = value.length;\n  const initDocumentOptions = {\n    skipId: true,\n    willInit: true\n  };\n\n  for (let i = 0; i < len; ++i) {\n    if (!value[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, value[i]); // Check if the document has a different schema (re gh-3701)\n\n    if (value[i].$__ && (!(value[i] instanceof Constructor) || value[i][documentArrayParent] !== doc)) {\n      value[i] = value[i].toObject({\n        transform: false,\n        // Special case: if different model, but same schema, apply virtuals\n        // re: gh-7898\n        virtuals: value[i].schema === Constructor.schema\n      });\n    }\n\n    if (value[i] instanceof Subdocument) {\n      // Might not have the correct index yet, so ensure it does.\n      if (value[i].__index == null) {\n        value[i].$setIndex(i);\n      }\n    } else if (value[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(value[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(value[i]); // if set() is hooked it will have no return value\n          // see gh-746\n\n          value[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(value[i], value, undefined, undefined, i); // if set() is hooked it will have no return value\n            // see gh-746\n\n            value[i] = subdoc;\n          } catch (error) {\n            const valueInErrorMessage = util.inspect(value[i]);\n            throw new CastError('embedded', valueInErrorMessage, value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n/*!\n * ignore\n */\n\n\nDocumentArrayPath.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n\n  schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);\n  return schematype;\n};\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n\n      if (sub === '$') {\n        continue;\n      }\n\n      if (sub.startsWith('$.')) {\n        sub = sub.substr(2);\n      }\n\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * ####Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\n\nDocumentArrayPath.defaultOptions = {};\nDocumentArrayPath.set = SchemaType.set;\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArrayPath;","map":{"version":3,"names":["ArrayType","require","CastError","EventEmitter","SchemaDocumentArrayOptions","SchemaType","ValidationError","discriminator","get","handleIdOption","util","utils","getConstructor","arrayPathSymbol","documentArrayParent","MongooseDocumentArray","Subdocument","DocumentArrayPath","key","schema","options","schemaOptions","_id","EmbeddedDocument","_createConstructor","prototype","$basePath","call","$isMongooseDocumentArray","Constructor","base","fn","defaultValue","default","arr","Array","isArray","parentSchemaType","$embeddedSchemaType","required","cast","value","doc","init","$isMongooseDocumentArrayElement","caster","schemaName","castNonArrays","Object","create","constructor","OptionsConstructor","baseClass","apply","arguments","$session","ownerDocument","proto","$__setSchema","$isArraySubdocument","events","i","methods","statics","name","tiedValue","getFunctionName","casterConstructor","baseCasterConstructor","defineProperty","error","discriminators","doValidate","array","scope","_this","cb","err","$isArrayValidatorError","count","length","updateValidator","isMongooseDocumentArray","path","callback","len","undefined","$__validate","doValidateSync","schemaTypeError","resultError","subdocValidateError","validateSync","getDefault","ret","_subdoc","isNew","assign","$__","activePaths","prev","selected","subdoc","_opts","transform","virtuals","inspect","markModified","skipDocumentArrayCast","arrayPath","initDocumentOptions","skipId","willInit","toObject","__index","$setIndex","scopePaths","id","deepEqual","set","valueInErrorMessage","clone","schematype","validators","slice","requiredValidator","fields","keys","hasKeys","sub","startsWith","substring","substr","defaultOptions","module","exports"],"sources":["/Users/juliachu/Dropbox/CS/market/node_modules/mongoose/lib/schema/documentarray.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayType = require('./array');\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaDocumentArrayOptions =\n  require('../options/SchemaDocumentArrayOptions');\nconst SchemaType = require('../schematype');\nconst ValidationError = require('../error/validation');\nconst discriminator = require('../helpers/model/discriminator');\nconst get = require('../helpers/get');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst util = require('util');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\n\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArrayPath(key, schema, options, schemaOptions) {\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const parentSchemaType = this;\n  this.$embeddedSchemaType = new SchemaType(key + '.$', {\n    required: get(this, 'schemaOptions.required', false)\n  });\n  this.$embeddedSchemaType.cast = function(value, doc, init) {\n    return parentSchemaType.cast(value, doc, init)[0];\n  };\n  this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDocumentArrayPath.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nDocumentArrayPath.options = { castNonArrays: true };\n\n/*!\n * Inherits from ArrayType.\n */\nDocumentArrayPath.prototype = Object.create(ArrayType.prototype);\nDocumentArrayPath.prototype.constructor = DocumentArrayPath;\nDocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/embedded'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n\n    this.$session(this.ownerDocument().$session());\n  }\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {String} [value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @see discriminators /docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nDocumentArrayPath.prototype.discriminator = function(name, schema, tiedValue) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    err.$isArrayValidatorError = true;\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      err.$isArrayValidatorError = true;\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!array.isMongooseDocumentArray) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n        if (!(error instanceof ValidationError)) {\n          error.$isArrayValidatorError = true;\n        }\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidateSync = function(array, scope) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    schemaTypeError.$isArrayValidatorError = true;\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.getDefault = function(scope) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nDocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n  const _opts = { transform: false, virtuals: false };\n  options = options || {};\n\n  if (!Array.isArray(value)) {\n    if (!init && !DocumentArrayPath.options.castNonArrays) {\n      throw new CastError('DocumentArray', util.inspect(value), this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  if (!(value && value.isMongooseDocumentArray) &&\n      !options.skipDocumentArrayCast) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  if (options.arrayPath != null) {\n    value[arrayPathSymbol] = options.arrayPath;\n  }\n\n  const len = value.length;\n  const initDocumentOptions = { skipId: true, willInit: true };\n\n  for (let i = 0; i < len; ++i) {\n    if (!value[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, value[i]);\n\n    // Check if the document has a different schema (re gh-3701)\n    if ((value[i].$__) &&\n        (!(value[i] instanceof Constructor) || value[i][documentArrayParent] !== doc)) {\n      value[i] = value[i].toObject({\n        transform: false,\n        // Special case: if different model, but same schema, apply virtuals\n        // re: gh-7898\n        virtuals: value[i].schema === Constructor.schema\n      });\n    }\n\n    if (value[i] instanceof Subdocument) {\n      // Might not have the correct index yet, so ensure it does.\n      if (value[i].__index == null) {\n        value[i].$setIndex(i);\n      }\n    } else if (value[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(value[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(value[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          value[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(value[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            value[i] = subdoc;\n          } catch (error) {\n            const valueInErrorMessage = util.inspect(value[i]);\n            throw new CastError('embedded', valueInErrorMessage,\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substr(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * ####Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option - The option you'd like to set the value for\n * @param {*} value - value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nDocumentArrayPath.defaultOptions = {};\n\nDocumentArrayPath.set = SchemaType.set;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArrayPath;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}